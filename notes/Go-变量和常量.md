# Go - 变量和常量

关键字var用于声明变量；关键字const用于声明常量。



## 变量

### 变量的声明

变量的声明包括三部分：

1. 指定变量名
2. 设置变量类型
3. 设置变量初始值

其中，变量类型和初始值在声明的时候，**可以省略其中的一个，但是不能同时省略**。

变量的声明形式有以下两种：

- var声明（使用关键字“var”进行变量的声明）
- 短变量声明（不使用关键字“var”，直接使用短变量声明）

#### var声明

##### 单个变量的声明形式

```
var name type = 表达式
或
var name type
或
var name = 表达式
```

例如：

```go
var name string = "hello go"
var name2 string
var name3 ="hello go"
```

声明变量时，需要注意：

- type类型和表达式可以省略其中的一个，但不能同时省略。如果类型省略，它的类型将由表达式决定。
- 当省略了表达式时，变量的初始值为对应的类型的零值——数字类型的默认值为0；布尔类型的默认值为false；字符串类型的默认值为“”，接口和其他引用类型的默认值为nil；复合类型（数组或结构体）中的每一个元素或成员默认值都为对应类型的零值。

##### 多个变量的声明形式

使用变量列表，同时声明多个不同类型的变量。

```go
var a, b, c int
var e, f, g = true, 2.3, "go"
//声明变量并初始化
var f, err = os.Open(name)

var (
	a int = 10
	b int = 30
	c     = 40
)
```

#### 短变量声明

不能在包作用域中使用变量简短声明。

##### 单个变量的声明形式

```
name := 表达式
```

例如：

```go
a := 4.5
b := a * 2
```

短变量的声明主要用在局部变量的声明和初始化中，通常比较短小灵活。

如果变量会在初始化表达式后类型发生变化，或者之后才对变量赋值，这种情况下通常使用var声明变量。

##### 多个变量的声明形式

与var声明一样，多个变量也可以使用短变量声明的方式和初始化：

```go
i , j := 0, 1
f, err := os.Open(name)
```

通常，只有对可读性有帮助的时候，才会使用多个初始化表达式来进行多个变量的同时声明，例如短小且天然一组的for循环的初始化。

##### 短变量声明特殊情况

短变量在声明时，并不是所有在左边的变量都需要声明，如果左边的某些变量已经在同一个语法块中声明过了，那么对于这些变量，短声明的行为等同于赋值。

```go
in, err := os.Open(infile)
out, err := os.Create(outfile) //这里仅声明了out，但向已有的err变量赋了值
```

注意：短变量声明最少要声明一个新变量，否则将会编译错误。并且只有在**同一个**语法块中已经存在变量的情况下，短变量声明的行为才和赋值操作一样，外层的声明将被忽略。

短变量声明可以应用在if、for、switch语句中。

#### 变量声明的重点

变量在声明时，需要指定变量名和初始类型（类型和初始值可以二选一），其中`:=`的作用和var相同，都是表示声明，虽然var声明时也可以指定“=” ，但是这里的“=”表示的是初始化值的意思。只有在没有var或者`:=`出现时，使用“=”才表示真正的赋值，指的是将右边的值赋给左边的对应变量。

```go
i , j =j , i //交换i和j的值
```

### 变量的生命周期

生命周期指的是：在程序执行过程中，变量存在的时间段。

包级别的变量：它的生命周期是整个程序的执行时间。

局部变量的生命周期：

- 每次执行声明语句时创建一个新的实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收。
- 函数的参数和返回值也是局部变量，它们在其闭包函数被调用的时候创建。

#### 变量逃逸

```go
var global *int
func f() {
	var x int
	x = 1
	global = &x
}
```

虽然x是一个局部变量，但是它在f函数返回以后还可以通过global变量访问，这种情况称为x从f中逃逸。因此，在上述代码中，x一定使用的是堆空间。

注意：每一次变量逃逸都需要一次额外的内存分配过程。如果在长生命周期对象中，保持着短生命周期对象不必要的指针，就会发生变量逃逸。特别是在全局变量中，这种变量逃逸会阻止垃圾回收器回收短生命周期的对象空间。

### 作用域

声明的作用域是指用到声明时所声明名字的源代码段。

Go的作用域通常会随着大括号`{}`的出现而开启和结束。

#### 变量的作用域和生命周期的区别

作用域：是声明在程序文本中出现的区域，它是一个编译时属性。

生命周期：是变量在程序执行期间，能被程序的其他部分所引用的起止时间，它是一个运行时属性。

#### 变量的作用域

在全局块中声明的变量对于整个程序可见，在包级别（在任何函数外）的声明，可以被同一个包里的任何文件引用。

控制流标签（如 break、continue 和 goto 语句使用的标签）的作用域是整个外层函数。

switch语句中的每个case都拥有自己独立的作用域，而if语句中的作用域不受条件分支的限制，作用在整个if语句中。

在Go语言中，可以声明一个和包级别变量同名的局部变量，这种情况下，局部变量的声明将会覆盖外部变量的声明，使外部变量不可访问，但通常不建议这么做。

当编译器遇到一个名字的引用时，将从最内层的封闭词法块到全局块寻找其声明，如果没有找到，会报“undeclared name”错误；如果在内层和外层都存在这个声明，内层的将先被找到。这种情况下，内层声明将覆盖外部声明。

和C#语言中的if语句不同，在Go语言中，if语句的条件部分，可以先声明变量，再定义条件语句，这种情况下，声明的变量可以被if语句的else部分访问。例如：

```go
package main

import "fmt"

func f() int {
	return 1
}
func g(n int) int {
	return n + 1
}
func main() {
	if x := f(); x == 0 { //定义变量x，值为1
		fmt.Println(x)
	} else if y := g(x); x == y { //定义变量y，值为x+1=2
		fmt.Println(x, y) //如果满足条件时：输出1,1
	} else {
		fmt.Println(x, y) //输出：1，2
	}
	//fmt.Println(x, y) //编译错误
}
```

同样的规则也可以应用于switch语句。

在包级别，声明的顺序和它们的作用域没有关系，所以一个声明可以引用它自己或者跟在它后面的其他声明。

注意：短变量声明依赖一个明确的作用域。

下面是一个错误的示例，本意是想在函数的内部获取值，然后将其传给包级别的变量：

```go
var cwd string

func init() {
	//编译错误
	cwd, err := os.Getwd() //此处相当于新声明了一个局部变量cwd，由于下文并没有对cwd进行过任何引用，因此该处会提示编译错误：未使用cwd
	if err != nil {
		print(err)
	}
}
```

上述代码内层cwd的声明让外部的声明不可见，所以这个语句没有按预期更新包级别的cwd变量。解决办法是不要使用`:=`，而是使用var声明err，并采用赋值符`=`进行操作。代码如下：

```go
var cwd string

func init() {
	var err error
	cwd, err = os.Getwd()
	if err != nil {
		print(err)
	}
}

```



## 常量

使用const关键词来声明常量，除此之外，程序中的每个字面量值（literal value）也都是常量。

Go语言不会为常量推断类型，而是直接将其标识为无类型（untyped），因此为一个常量赋值为一个超大的整数并不会引发溢出错误。这意味着那些大小非同寻常的数值可以被直接使用。



### 常量生成器 iota

可以实现类似枚举的功能。

未使用iota：

```go
const (
	cpp    = 0
	java   = 1
	python = 2
	golang = 3
)
```

使用了iota之后：

```go

const (
	cpp = iota
	java
	python
	golang
)
fmt.Println(cpp, java, python, golang) //输出：0 1 2 3
```

忽略其中的某个常量：

```go
const (
	cpp = iota
	_
	python
	golang
)
fmt.Println(cpp, python, golang) //输出：0 2 3
```

iota可以直接参与运算：

```go
const (
	a = 2 * iota
	b
	c
	d
)
fmt.Println(a, b, c, d) //输出：0 2 4 6
```

例如：

```go
const (
	b = 1 << (10 * iota)
	kb
	mb
	gb
	tb
	pb
)
fmt.Println(b, kb, mb, gb, tb, pb)
```

输出：

```
1 1024 1048576 1073741824 1099511627776 1125899906842624
```



### 无类型常量

只有常量才可以是无类型的。Go语言不会为没有声明为具体类型的常量进行类型推断，而是直接将其标识为无类型。

例如，如果存在不同类型的变量a和变量b，如果直接进行运算，会报编译错误。

```go
var a = 20
var b = 2.5
fmt.Printf("%T %T", a, b)  //输出：int float64
//下述语句将会报编译错误，不同类型不能直接进行运算
fmt.Println(a / b)
```

改为常量声明之后，不会报编译错误，并且可以计算出正确的结果。

```go
const a = 20
const b = 2.5
fmt.Printf("%T %T", a, b) //输出：int float64
//改为const之后，不会报编译错误
fmt.Println(a / b)	//输出：8
```

原因是Go语言不会为常量推断类型，而是直接将其标识为无类型。

但是如果明确的指定了常量的具体类型，仍然会报编译错误：

```go
const a int = 20
const b float64 = 2.5
fmt.Printf("%T %T", a, b) //输出：int float64
//明确指明常量类型后，会报编译错误
fmt.Println(a / b)
```

正因如此，上文提到过，程序中的每个字面量值都是常量，当没有明确指明常量的类型时，不会为常量推断类型，因此下述语句可以通过编译，不会报类型不匹配的错误，并能够输出正确的结果：

```go
var ans float64 = 15 + 25 + 5.2	//字面量常量不进行类型推断
fmt.Println(ans) //输出：45.2
```

而下面语句，将会报错：

```go
a, b := 15, 25
c := 5.2
//进行了类型推断，导致类型不匹配，提示编译错误
c := a + b + c
```

