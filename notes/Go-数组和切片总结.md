# Go-数组和切片总结

### 关于类型

数组的长度是其类型的一部分，数组的长度在声明它的时候就必须给定，并且之后不会再改变。

切片的类型字面量中只有元素的类型，而没有长度。

指定了长度是数组，否则就是切片。

```go
myArray := [3]string{"a","b","c"}
mySlice := []string{"a","b","c"}
```

数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。

Go 语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；

而 Go 语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。

（在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了）

### 关于长度（len）和容量（cap）

数组的容量永远等于其长度，都是不可变的。

一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。

```go
func main() {
	//创建长度为5的切片
	s1 := make([]int, 5)
	fmt.Printf("s1切片的长度：%d \n", len(s1)) //输出：5
	fmt.Printf("s1切片的容量：%d \n", cap(s1)) //输出：5
	fmt.Printf("s1切片的值：%d \n", s1)       //输出：[0 0 0 0 0]

	//创建长度为5，容量为8的切片
	s2 := make([]int, 5, 8)
	fmt.Printf("s2切片的长度：%d \n", len(s2)) //输出：5
	fmt.Printf("s2切片的容量：%d \n", cap(s2)) //输出：8
	fmt.Printf("s2切片的值：%d \n", s2)       //输出：[0 0 0 0 0]

	s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
	s4 := s3[3:6]
	fmt.Printf("s4切片的长度：%d \n", len(s4)) //输出：3
	fmt.Printf("s4切片的容量：%d \n", cap(s4)) //输出：5
	fmt.Printf("s4切片的值：%d \n", s4)       //输出：[4 5 6]
}
```

由于s4是通过在s3上施加切片操作得来的，所以s3的底层数组就是s4的底层数组。

又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。所以，s4的容量就是其底层数组的长度8, 减去s4所在的起始索引3，最终算出容量为5。

注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过s4看到s3中最左边的那 3 个元素。

在使用append函数添加元素时，如果无需扩容，append函数返回的是指向**原**底层数组的**原**切片，而在需要扩容时，append函数返回的是指向**新**底层数组的**新**切片。