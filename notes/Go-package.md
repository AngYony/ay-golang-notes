# Go - package



## 包（package）

在Go语言中，包的作用类似C#中的命名空间。

包的本质就是创建不同的文件夹，来存放程序文件。

因此：

- 包的名称一般会与源码文件所在的目录同名，当然也可以不同名，如果不同名，那么在构建、安装的过程中会以代码包名称为准。
- 由于目录可以有子目录，所以代码包也可以有子包。
- 具有相同父级目录的Go代码的 package 要保持一致。（同一级目录的Go代码包名称要相同）
- 一个代码包中可以包含任意个以.go 为扩展名的源码文件。
- import引入的是包所在的目录，目录名可以和包名不同，调用时，必须使用包名.函数名()的方式，而不是目录名.函数名()，当使用了别名，就只能按照别名的.函数名()的方式调用。
- 同一个目录下，只允许有一个包，不允许有多个不同名的包声明，除非使用文件夹嵌套起来。
- 每一个含有main函数的文件，必须单独放在一个目录里。同一个目录下的多个go文件中，只允许出现一个main方法。如果多个文件有多个main方法，必须使用目录给隔开，这些文件可以都使用同一个包名是允许的。可参考官方的tools。



### 导入其他包

在Go程序里，引入其他包使用import关键字，需要指明包所在的目录，在工作区中，一个代码包的导入路径实际上就是从%GOPATH/src 子目录，到该包的实际存储位置的相对路径。

文件所在的完整目录名的尾部（$GOPATH/src/之后的）就是包导入的路径。

```go
package main

import (
	"chapter2/tempconv"
	"fmt"
)
```

除了导入路径之外，每个包还有一个包名，它以短名字的形式（且不必是唯一的）出现在包的声明中。

按约定，包名匹配导入路径的最后一段，例如“chapter2/tempconv”的包名是tempconv。这种由导入声明给导入的包绑定的短名字，可以用来在整个文件中引用包的内容。为了避免冲突，导入声明还可以设定一个可选的名字。

 如果导入一个没有被引用的包，将会触发一个编译错误。这个检查有助于消除代码演进过程中不再需要的依赖。

### 包的初始化

包的初始化按照如下过程进行：

1. 首先初始化包级别的变量，这些变量按照声明顺序初始化，在依赖已解析完毕的情况下，根据依赖的顺序进行。例如：

   ```go
   var a = b + c //3：最后把a初始化为3
   var b = f()   //2：接着通过调用f()将b初始化为2
   var c = 1     //1：首先初始化c为1
   func f() int  { return c + 1 }
   ```

2. 如果包由多个.go文件组成，初始化按照编译器收到文件的顺序进行：go工具会在调用编译器前将.go文件进行排序。

   对于包级别的每一个变量，生命周期从其值被初始化开始，但是对于其他一些变量，比如数据表，初始化表达式不是简单地设置它的初始化值，而是需要调用init()函数（见下述）。

3. 包的初始化按照在程序中导入的顺序来进行，依赖顺序优先，每次初始化一个包。例如，如果包p导入了包q，可以确保q在p之前已完全初始化。初始化过程是自下向上的，main包最后初始化。在这种方式下，在程序的main函数开始执行前，所有的包已初始化完毕。

执行顺序总结：

包级别变量（全局变量）=> 依赖包的init() => 本包的init() => main函数



#### init()

go中的每个源文件中都可以包含**一个或多个**init函数，该函数会在main函数执行前，被go运行框架调用，也就是说init会在main函数前被调用。

init()函数通常用于初始化操作。

```go
func init(){...}
```



使用init()函数时需要注意的地方：

- init函数不能被手动的调用和被引用；

- 在 main 被执行前，main包所有依赖的其他 package 的 init 方法都会被执行；
- 不同包的 init 函数按照包导入的依赖关系决定执行顺序；
- 在同一个文件里，如果有多个init函数，将会按照init函数**声明的顺序**自动执行。

 



