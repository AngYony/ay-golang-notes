# Go语言中零散的知识点

### go中 make和new 有什么区别？

make 是专门用来创建 slice、map、channel 的值的。它返回的是被创建的值，并且立即可用。

new 是申请一小块内存并标记它是用来存放某个值的。它返回的是指向这块内存的指针，而且这块内存并不会被初始化。或者说，对于一个引用类型的值，那块内存虽然已经有了，但还没法用（因为里面没有针对那个值的数据结构）。

所以，对于引用类型的值，不要用 new，能用 make 就用 make，不能用 make 就用复合字面量来创建。

new：用来分配值类型，返回的是指针。

make：用来分配引用类型，返回的是类型值。



### 查看变量的数据类型和占用的字节大小

```go
wy := true
// 获取数据类型
fmt.Printf("%T \n", wy)
fmt.Println(reflect.TypeOf(true))
// 获取占用空间大小，单位字节
fmt.Println(unsafe.Sizeof(wy))
```



### `%`取模计算公式

==在Go语言中，取模运算符 % 仅能用于整数，用于取余计算。并且，**取模余数的正负号总是与被除数（分子）一致**==，例如：-5%3 和 -5%-3 计算结果都是 -2。整数的除法运算（/）结果仍然是整数（会舍弃小数部分），例如 5/4结果为1。

取模计算推导公式：

```
a % b = a - (a / b * b)
```

注意：这里的`a/b`是按照四则运算后的取整操作。

例如：

```go
-10 % 3 = -10 - (-10) / 3 * 3 = -10 - (-3) * 3 = -10 - (-9) = -1
```

```go
10 % -3 = 10 - 10 / (-3) * (-3) = 10 - (-3) * (-3) = 10 -9 = 1
```

```
-10 % -3 = -10 - (-10) / (-3) * (-3) = -10 - 3 * (-3) = -10 - (-9) = -1
```

```
10 % 3 =1
```

验证：

```go
fmt.Println(10 % 3)   // 输出：1
fmt.Println(10 % -3)  // 输出：1
fmt.Println(-10 % 3)  // 输出：-1
fmt.Println(-10 % -3) // 输出：-1
```

总结：不管分母是否正负，只要分子（被除数）为负数，取模后的结果也为负数；分子（被除数）为正数，取模结果也为正数。



### 数字转字节数组

如果需要将一个数字转换为字节，或者将字节转换为数字，需要使用到binary包。

例如uint32占用4个字节，如果需要将uint32转换为字节数组：

```go
var pkgLen uint32 = uint32(len(data))
var buf [4]byte // 因为uint32数字存储需要4个字节，所以这里使用的是4个长度的字节数组
binary.BigEndian.PutUint32(buf[0:4], pkgLen)
```

反过来，将字节数组转换为uint32：

```go
buf := make([]byte, 1024*4)
var pkgLen uint32
pkgLen = binary.BigEndian.Uint32(buf[0:4])
```

