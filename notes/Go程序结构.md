# Go-程序结构

[TOC]

## 名称

Go语言中，定义一个名称（函数、变量、常量、类型、语句标签、包）需要遵循的规则：

- 名称必须以字母或下划线开头，其后由任意数量的数字、字母、下划线组成。
- 名称严格区分大小写，并且首字母的大小写决定了该名称的可见性是否挎包。
- 如果定义的名称想要被自己包之外的其他程序所引用，那么该名称必须以大写字母开头。
- 包的名称总是由小写字母组成。
- 在Go的编码风格中，名称习惯使用短名称，特别是作用域较小的局部变量。通常，名称的作用域越大，就使用越长且更有意义的名称。
- 名称由多个单词组合时，使用“驼峰式”风格（第一个单词首字母小写，其余单词首字母大写），而不是下划线。并且，当某个单词是由缩写形式构成的（例如：HTML），通常该单词在“驼峰式”风格中，使用相同的大小写。（例如：htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。）
- 不能与Go内置的关键字、预声明的常量、类型和函数同名。



## 声明

声明主要包括：变量（var）的声明、常量（const）的声明、类型（type）的声明、函数（func）的声明。

Go程序存储在一个或多个以.go为后缀的文件里，每一个文件都以package声明开头，表明文件属于哪个包。package后面是import声明，然后是包级别的类型、变量、常量、函数的声明。

注意：

- 包级别的声明是不区分顺序的。
- 包级别的声明对于同一个包里面的所有源文件都可见。
- 如果包级别的声明是以大写字母开头的，那么将会被自己包之外的其他程序可见。
- 局部声明仅在声明所在的函数内部可见，并且可能只对函数中的一小块区域可见。



## 变量

### 变量的声明

变量的声明包括三部分：

1. 指定变量名
2. 设置变量类型
3. 设置变量初始值

其中，变量类型和初始值在声明的时候，可以省略其中的一个，但是不能同时省略。

变量的声明有以下两种形式：

- var声明（使用关键字“var”进行变量的声明）
- 短变量声明（不使用关键字“var”，直接使用短变量声明）

#### var声明

##### 单个变量的声明形式

```
var name type = 表达式
或
var name type
或
var name = 表达式
```

例如：

```go
var name string = "hello go"
var name2 string
var name3 ="hello go"
```

声明变量时，需要注意：

- type类型和表达式可以省略其中的一个，但不能同时省略。如果类型省略，它的类型将由表达式决定。
- 当省略了表达式时，变量的初始值为对应的类型的零值——数字类型的默认值为0；布尔类型的默认值为false；字符串类型的默认值为“”，接口和其他引用类型的默认值为nil；复合类型（数组或结构体）中的每一个元素或成员默认值都为对应类型的零值。

##### 多个变量的声明形式

使用变量列表，同时声明多个不同类型的变量。

```go
var a, b, c int
var e, f, g = true, 2.3, "go"
//声明变量并初始化
var f, err = os.Open(name)
```

#### 短变量声明

##### 单个变量的声明形式

```
name := 表达式
```

例如：

```go
a := 4.5
b := a * 2
```

短变量的声明主要用在局部变量的声明和初始化中，通常比较短小灵活。

如果变量会在初始化表达式后类型发生变化，或者之后才对变量赋值，这种情况下通常使用var声明变量。

##### 多个变量的声明形式

与var声明一样，多个变量也可以使用短变量声明的方式和初始化：

```go
i , j := 0, 1
f, err := os.Open(name)
```

通常，只有对可读性有帮助的时候，才会使用多个初始化表达式来进行多个变量的同时声明，例如短小且天然一组的for循环的初始化。

##### 短变量声明特殊情况

短变量在声明时，并不是所有在左边的变量都需要声明，如果左边的某些变量已经在同一个语法块中声明过了，那么对于这些变量，短声明的行为等同于赋值。

```go
in, err := os.Open(infile)
out, err := os.Create(outfile) //这里仅声明了out，但向已有的err变量赋了值
```

注意：短变量声明最少要声明一个新变量，否则将会编译错误。并且只有在**同一个**语法块中已经存在变量的情况下，短变量声明的行为才和赋值操作一样，外层的声明将被忽略。

#### 变量声明的重点

变量在声明时，需要指定变量名和初始类型（类型和初始值可以二选一），其中`:=`的作用和var相同，都是表示声明，虽然var声明时也可以指定“=” ，但是这里的“=”表示的是初始化值的意思。只有在没有var或者`:=`出现时，使用“=”才表示真正的赋值，指的是将右边的值赋给左边的对应变量。

```go
i , j =j , i //交换i和j的值
```

### 指针

指针的值是一个变量的地址（可以直接将指针理解为变量的地址），因此，一个指针指示了变量的值所保存的位置。不是所有的值都有地址，但是所有的变量都有。使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值。

例如，声明了一个变量x：

```go
var x int
```

获取变量x的地址，可以使用表达式：&x，&x表示的是获取一个指向整型变量x的指针。因此&x就代表着指针本身，它的值是一个变量的地址。在这里，它的类型是整型指针（*int）。

如果将一个指针直接赋值给了一个变量p，例如：

```go
p := &x
```

它表示的意思是：p包含变量x的地址，或者p指向变量x（指针类型的零值是nil，测试p!=nil，结果为true，说明p指向一个变量（p的值是一个变量的地址））。

在Go语言中，p指向的变量可以用`*p`来表示，也就是说这里的变量x可以直接通过`*p`来指代，换句话说，`*p`就代表着变量x，既然是变量，因此它也可以出现在赋值操作符左边，用于更新变量的值。

```go
x := 1
p := &x         //p是整型指针，指向x
fmt.Println(*p) // 输出：1
*p = 2          //*p指代的就是变量x，因此相当于是：x=2
fmt.Println(x)  //输出：2
```

综上所述：

`&x`：代表着指针本身，它的值是一个变量的地址。假如存在`p := &x`，那么p的值就是变量x的地址，此时，

`*p`：代表着p指向的变量，即x变量本身，`*p`是变量x的别名，因此`*p`也被称为变量x的指针别名。

指针是可以比较的，两个指针**当且仅当**指向同一个变量或者两者都是nil的情况下才相等。

```go
var w, y int
fmt.Println(&w == &w, &w == &y, &y == nil) //输出：true false false
```

在Go语言中，函数返回局部变量的地址（指针）是非常安全的，例如：

```go
func wy() *int {
	v := 1
	return &v //返回一个指针
}
var p1 = wy()   //p1是一个指针
fmt.Println(p1) //输出：0xc00005c080
var p2 = wy()   //p2是一个指针
fmt.Println(p2) //输出：0xc00005c088
fmt.Println(p1 == p2) //输出：false
```

上述代码中，通过调用wy()产生的局部变量v即使在函数调用返回后依然存在，指针p1依然引用它，并且每次调用wy()都会返回一个不同的指针值。

可以将指针作为参数传递给函数，在函数的内部通过`*p`来获取指向的变量，从而能够实现让函数更新间接传递的变量值。

```go
//参数是一个整型指针
func incr(p *int) int {
	//获取指针指向的变量，并加1
	*p++
	return *p //返回指向的变量的值
}
m := 1
incr(&m)              //传入m指针，m加1
fmt.Println(m)        //输出：2
fmt.Println(incr(&m)) //再次传入m指针，m再次加1，并返回m的值，所以输出：3
fmt.Println(m)        //输出：3
```

上述代码中，`*p`是变量m的指针别名，指针别名允许我们不用变量的名字来访问变量。

下面是一个flag包使用指针相关的示例，自定义了两个标识参数，-n会忽略正常输出时结尾的换行符；-s使用sep替换默认参数输出时使用的空格分隔符。

```go
//echo4 输出其命令行参数
package main

import (
	"flag"
	"fmt"
	"strings"
)
//变量sep和n是指向标识变量的指针，因此必须通过*sep和*n来访问
var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")

func main() {
	flag.Parse() //更新标识变量的默认值
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println("结束")
	}
}
```

执行结果：

```powershell
PS E:\go_cxsjyy\src\chapter2\echo4> go build
PS E:\go_cxsjyy\src\chapter2\echo4> .\echo4.exe a bc def
a bc def结束
PS E:\go_cxsjyy\src\chapter2\echo4> .\echo4.exe -s / a bc def
a/bc/def结束
PS E:\go_cxsjyy\src\chapter2\echo4> .\echo4.exe -n a bc def
a bc def
PS E:\go_cxsjyy\src\chapter2\echo4> .\echo4.exe -help
Usage of E:\go_cxsjyy\src\chapter2\echo4\echo4.exe:
  -n    omit trailing newline
  -s string
        separator (default " ")
PS E:\go_cxsjyy\src\chapter2\echo4>
```

总结：指针的作用就是实现其他语言（C#）中变量按照引用类型传递的方式。

### new函数

new函数用于创建指针。

```go
p := new(T)
```

表达式`new(T)`用于创建一个未命名的T类型的变量，并初始化为T类型的零值，并且返回其地址（指针），地址类型为`*T`。例如，当T为int时，`new(int)`返回的就是`*int`，表示的是整型指针。

```go
p := new(int)	//定义类型是整型指针（*int）的p，指针p指向未命名的int变量
fmt.Println(p)  //输出：0xc00005c080
fmt.Println(*p) //输出：0
*p = 2          //把未命名的int设置为2
fmt.Println(*p) //输出2
a := new(int)	//每一次调用new都返回一个具有唯一地址的不同变量
b := new(int)
fmt.Println(a) 	//输出：0xc00005c0b0
fmt.Println(b) 	//输出：0xc00005c0b8
```

使用new函数创建未知变量的指针时，由于不需要引入（和声明）一个虚拟的名字，因此可以直接在表达式中使用。

下面的两个`newInt`函数行为相同，相互等价：

```go
func newInt() *int {
	return new(int)
}
func newInt2() *int {
	var dumy int
	return &dumy
}
```

备注：new是一个预声明的函数，不是一个关键字。

### 变量的生命周期

生命周期指的是：在程序执行过程中，变量存在的时间段。

包级别的变量：它的生命周期是整个程序的执行时间。

局部变量的生命周期：

- 每次执行声明语句时创建一个新的实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收。
- 函数的参数和返回值也是局部变量，它们在其闭包函数被调用的时候创建。

#### 变量逃逸

```go
var global *int
func f() {
	var x int
	x = 1
	global = &x
}
```

虽然x是一个局部变量，但是它在f函数返回以后还可以通过global变量访问，这种情况称为x从f中逃逸。因此，在上述代码中，x一定使用的是堆空间。

注意：每一次变量逃逸都需要一次额外的内存分配过程。如果在长生命周期对象中，保持着短生命周期对象不必要的指针，就会发生变量逃逸。特别是在全局变量中，这种变量逃逸会阻止垃圾回收器回收短生命周期的对象空间。



## 赋值

赋值语句用来更新变量所指的值。

```go
x = 1                       //有名称的变量赋值
*p = true                   //间接变量赋值
person.name = "bob"         //结构体成员赋值
count[x] = count[x] * scale //数组元素的赋值
y *= 2                      //等同于：y=y*2
v++
v--
```

### 多重赋值

多重赋值：多个变量一次性被赋值。

```go
i, j, k = 2, 3, 5
```

多重赋值在实际更新变量前，右边所有的表达式会先被推演。

示例一，交换两个变量的值：

```go
x，y = y, x
a[i], a[j] = a[j], a[i]
```

示例二，计算两个整数的最大公约数：

```go
func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}
```

示例三，计算斐波那契数列的第n个数：

```go
func fib(n int) int {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		x, y = y, x+y
	}
	return x
}
```

### 可赋值性

不管隐式还是显式赋值，如果左边的变量和右边的值类型相同，它就是合法的。

nil可以被赋给任何接口变量或引用类型。

如果两个值能够使用==和!=进行比较，必须满足的条件：其中一个操作数相对于另一个操作数的类型必须是可赋值的。



## 类型声明

type声明定义了一个新的命名类型，它和某个已有类型使用同样的底层类型。

命名类型的主要作用就是与底层类型的使用相互隔离，避免相互混乱使用。

即使两个命名类型使用了相同的底层类型，它们也不是相同的类型，仍然是不同的类型，所以它们不能使用算术表达式进行比较和合并。

命名类型的声明：

```
type name underlying-type
```

类型的声明通常出现在包级别，这里命名的类型在整个包中可见，如果名字是导出的（开头使用大写字母），其他的包也可以访问它。

命名类型的底层类型决定了它的结构和表达方式，以及它支持的内部操作集合，这些内部操作与直接使用底层类型的情况相同。

```go
package main

//定义两个类型
type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	boilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
	return Fahrenheit(c*9/5 + 32)
}
func FToC(f Fahrenheit) Celsius {
	return Celsius((f - 32) * 5 / 9)
}
func main() {
	//fmt.Println(Celsius(2.0) == Fahrenheit(2.0)) //编译错误
	fmt.Println(Celsius(2.0) == Celsius(Fahrenheit(2.0))) //输出true
    fmt.Println(float64(Celsius(2.0)) == float64(Fahrenheit(2.0))) //输出true
}
```

在上述代码中，即使Celsius和Fahrenheit都使用了相同的底层类型float64，它们也不是相同的类型，所以不能使用算术表达式进行比较和合并。要想解决这个问题，必须显式的进行类型转换。

对于每个类型T，都有一个对应的类型转换操作T(x)将值x转换为类型T。

如果两个类型具有相同的底层类型，或二者都是指向相同底层类型变量的未命名指针类型，则二者是可以相互转换的。

类型转换不改变类型值的表达方式，仅改变类型。

命令类型一般通常用于底层类型是复杂结构体类型，可以避免一遍遍地重复写复杂的类型。

### Go语言中的类C#扩展方法

在C#语言中，可以定义类型的扩展方法，在Go语言中，也提供了这种方式。例如：

```go
func (c Celsius) String() string {
	return fmt.Sprintf("%g℃", c)
}
```

上述代码中，Celsius类型的参数c出现在了函数String()名字的前面，表示名字叫String的方法关联到Celsius类型，类似于C#中类型的扩展方法，这样每次调用Celsius类型的变量时，就可以调用它的扩展方法String()了。

```go
c := FToC(212.0)		//先转换为Celsius类型
fmt.Println(c)          //输出100℃，Println()需要传入一个字符串，隐式被调用
fmt.Println(c.String()) //输出100℃
fmt.Printf("%v\n", c)   //输出100℃，不需要显式调用字符串
fmt.Printf("%s\n", c)   //输出100℃
fmt.Printf("%g\n", c)   //输出100，不调用字符串
fmt.Println(float64(c)) //输出100，不调用字符串
```



## 包和文件

在Go语言中，包的作用类似C#中的命名空间，一个包的源代码保存在一个或多个以.go结尾的文件中，文件所在的完整目录名的尾部（$GOPATH/src/之后的）就是包导入的路径。

每一个包给它的声明提供独立的命名空间。可以通过控制变量在包外面的可见性或导出情况来隐藏信息：以大写字母开头的标识符对其他包可见。

在下面的示例中，两个不同的.go文件都在同一个包中，temps.go文件中的代码如下：

```go
//定一个包和包级别的常量和类型声明，并且首字母均大写
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilingC      Celsius = 100
)

func (c Celsius) String() string {
	return fmt.Sprintf("%g℃", c)
}
func (f Fahrenheit) String() string {
	return fmt.Sprintf("%g℉", f)
}
```

由于上述代码定义的是包级别的常量和类型声明，因此它们可以在同一个包中直接被引用，并且它们的名字都是以大写字母开头的，因此也可以在其他包中被引用。

conv.go文件中的代码如下：

```go
//定义温度相互转换的方法
package tempconv

func CToF(c Celsius) Fahrenheit {
	return Fahrenheit(c*9/5 + 32)
}

func FtoC(f Fahrenheit) Celsius {
	return Celsius((f - 32) * 5 / 9)
}
```

如果不是在同一个包中调用，而是在其他包中使用上述定义的常量和类型声明，需要导入其所在的包，并且通过包名的形式进行访问。

例如，下述代码在main包中调用tempconv包中的成员，此时需要使用`tempconv.成员`的形式进行访问：

```go
//测试多个.go文件在同一个包中的调用情况
package main

import (
	"chapter2/tempconv"
	"fmt"
)

func main() {
	fmt.Printf("TTTT! %v\n", tempconv.AbsoluteZeroC) //输出：TTTT! -273.15℃
	fmt.Println(tempconv.CToF(tempconv.BoilingC))    //输出：212℉
}
```

package声明的前面通常需要写明对整个包进行描述的文档注释。并且每一个包里只有一个文件应该包含该包的文档注释。扩展的文档注释通常放在一个文件中，按惯例名字叫做doc.go。

注意：

- 包级别的成员，在其所在的包中的任意文件都可见，可以直接通过名称来引用。
- 如果包级别的声明以大写字母开头，那么它将在其他包中也可见，可以在其他包中通过`包名.成员`的形式进行引用。

### 导入

在Go程序里，每一个包通过称为`导入路径`的唯一字符串来标识。

```go
package main

import (
	"chapter2/tempconv"
	"fmt"
)
```

一个导入路径标注一个目录，目录中包含构成包的一个或多个Go源文件。

除了导入路径之外，每个包还有一个包名，它以短名字的形式（且不必是唯一的）出现在包的声明中。

按约定，包名匹配导入路径的最后一段，例如“chapter2/tempconv”的包名是tempconv。这种由导入声明给导入的包绑定的短名字，可以用来在整个文件中引用包的内容。为了避免冲突，导入声明还可以设定一个可选的名字。

如果导入一个没有被引用的包，将会触发一个编译错误。这个检查有助于消除代码演进过程中不再需要的依赖。

### 包的初始化

包的初始化按照如下过程进行：

1. 首先初始化包级别的变量，这些变量按照声明顺序初始化，在依赖已解析完毕的情况下，根据依赖的顺序进行。例如：

   ```go
   var a = b + c //3：最后把a初始化为3
   var b = f()   //2：接着通过调用f()将b初始化为2
   var c = 1     //1：首先初始化c为1
   func f() int  { return c + 1 }
   ```

2. 如果包由多个.go文件组成，初始化按照编译器收到文件的顺序进行：go工具会在调用编译器前将.go文件进行排序。

   对于包级别的每一个变量，生命周期从其值被初始化开始，但是对于其他一些变量，比如数据表，初始化表达式不是简单地设置它的初始化值，而是需要调用init()函数（见下述）。

3. 包的初始化按照在程序中导入的顺序来进行，依赖顺序优先，每次初始化一个包。例如，如果包p导入了包q，可以确保q在p之前已完全初始化。初始化过程是自下向上的，main包最后初始化。在这种方式下，在程序的main函数开始执行前，所有的包已初始化完毕。

#### init()

任何文件都可以包含任意数量的init函数，它的声明形式如下：

```go
func init(){...}
```

init函数不能被手动的调用和被引用，另一方面，它也是普通的函数。在每一个文件里，当程序启动的时候，init函数按照它们**声明的顺序**自动执行。



## 作用域

声明的作用域是指用到声明时所声明名字的源代码段。

### 变量的作用域和生命周期的区别

作用域：是声明在程序文本中出现的区域，它是一个编译时属性。

生命周期：是变量在程序执行期间，能被程序的其他部分所引用的起止时间，它是一个运行时属性。

### <span style='color:#aaaaaa'>~~语法块、词法块与全局块~~</span>

<span style='color:#aaaaaa'>~~语法块（block）：是由大括号围起来的一个语句序列，比如一个循环体或函数体。在语法块内部声明的变量对块外部不可见。~~</span>

<span style='color:#aaaaaa'>~~词法块：词法块既包括了显式写在大括号语法里的代码块，也包括其他没有显式包含在大括号中的声明代码。每一个包、每一个文件都是写在一个词法块里的。~~</span>

<span style='color:#aaaaaa'>~~全局块：包含了全部源代码的词法块，叫做全局块。~~</span>

<span style='color:#aaaaaa'>~~全局块的范围包含了词法块，而词法块的范围又包含了语法块。~~</span>

<span style='color:#aaaaaa'>~~全局块的范围类似于C#中的程序集类库，而词法块的范围类似于类库中的每一个命名空间。~~</span>

### 变量的作用域

在全局块中声明的变量对于整个程序可见，在包级别（在任何函数外）的声明，可以被同一个包里的任何文件引用。

控制流标签（如 break、continue 和 goto 语句使用的标签）的作用域是整个外层函数。

在Go语言中，可以声明一个和包级别变量同名的局部变量，这种情况下，局部变量的声明将会覆盖外部变量的声明，使外部变量不可访问，但通常不建议这么做。

当编译器遇到一个名字的引用时，将从最内层的封闭词法块到全局块寻找其声明，如果没有找到，会报“undeclared name”错误；如果在内层和外层都存在这个声明，内层的将先被找到。这种情况下，内层声明将覆盖外部声明。

和C#语言中的if语句不同，在Go语言中，if语句的条件部分，可以先声明变量，再定义条件语句，这种情况下，声明的变量可以被if语句的else部分访问。例如：

```go
package main

import "fmt"

func f() int {
	return 1
}
func g(n int) int {
	return n + 1
}
func main() {
	if x := f(); x == 0 { //定义变量x，值为1
		fmt.Println(x)
	} else if y := g(x); x == y { //定义变量y，值为x+1=2
		fmt.Println(x, y) //如果满足条件时：输出1,1
	} else {
		fmt.Println(x, y) //输出：1，2
	}
	//fmt.Println(x, y) //编译错误
}
```

同样的规则也可以应用于switch语句。

在包级别，声明的顺序和它们的作用域没有关系，所以一个声明可以引用它自己或者跟在它后面的其他声明。

注意：短变量声明依赖一个明确的作用域。

下面是一个错误的示例，本意是想在函数的内部获取值，然后将其传给包级别的变量：

```go
var cwd string

func init() {
	//编译错误
	cwd, err := os.Getwd() //此处相当于新声明了一个局部变量cwd，由于下文并没有对cwd进行过任何引用，因此该处会提示编译错误：未使用cwd
	if err != nil {
		print(err)
	}
}
```

上述代码内层cwd的声明让外部的声明不可见，所以这个语句没有按预期更新包级别的cwd变量。解决办法是不要使用`:=`，而是使用var声明err，并采用赋值符`=`进行操作。代码如下：

```go
var cwd string

func init() {
	var err error
	cwd, err = os.Getwd()
	if err != nil {
		print(err)
	}
}

```



















