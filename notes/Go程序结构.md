# Go-程序结构

[TOC]

## 名称

Go语言中，定义一个名称（函数、变量、常量、类型、语句标签、包）需要遵循的规则：

- 名称必须以字母或下划线开头，其后由任意数量的数字、字母、下划线组成。
- 名称严格区分大小写，并且首字母的大小写决定了该名称的可见性是否挎包。
- 如果定义的名称想要被自己包之外的其他程序所引用，那么该名称必须以大写字母开头。
- 包的名称总是由小写字母组成。
- 在Go的编码风格中，名称习惯使用短名称，特别是作用域较小的局部变量。通常，名称的作用域越大，就使用越长且更有意义的名称。
- 名称由多个单词组合时，使用“驼峰式”风格（第一个单词首字母小写，其余单词首字母大写），而不是下划线。并且，当某个单词是由缩写形式构成的（例如：HTML），通常该单词在“驼峰式”风格中，使用相同的大小写。（例如：htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。）
- 不能与Go内置的关键字、预声明的常量、类型和函数同名。



## 声明

声明主要包括：变量（var）的声明、常量（const）的声明、类型（type）的声明、函数（func）的声明。

Go程序存储在一个或多个以.go为后缀的文件里，每一个文件都以package声明开头，表明文件属于哪个包。package后面是import声明，然后是包级别的类型、变量、常量、函数的声明。

注意：

- 包级别的声明是不区分顺序的。
- 包级别的声明对于同一个包里面的所有源文件都可见。
- 如果包级别的声明是以大写字母开头的，那么将会被自己包之外的其他程序可见。
- 局部声明仅在声明所在的函数内部可见，并且可能只对函数中的一小块区域可见。



## 变量

### 变量的声明

变量的声明包括三部分：

1. 指定变量名
2. 设置变量类型
3. 设置变量初始值

其中，变量类型和初始值在声明的时候，可以省略其中的一个，但是不能同时省略。

变量的声明有以下两种形式：

- var声明（使用关键字“var”进行变量的声明）
- 短变量声明（不使用关键字“var”，直接使用短变量声明）

#### var声明

##### 单个变量的声明形式

```
var name type = 表达式
或
var name type
或
var name = 表达式
```

例如：

```go
var name string = "hello go"
var name2 string
var name3 ="hello go"
```

声明变量时，需要注意：

- type类型和表达式可以省略其中的一个，但不能同时省略。如果类型省略，它的类型将由表达式决定。
- 当省略了表达式时，变量的初始值为对应的类型的零值——数字类型的默认值为0；布尔类型的默认值为false；字符串类型的默认值为“”，接口和其他引用类型的默认值为nil；复合类型（数组或结构体）中的每一个元素或成员默认值都为对应类型的零值。

##### 多个变量的声明形式

使用变量列表，同时声明多个不同类型的变量。

```go
var a, b, c int
var e, f, g = true, 2.3, "go"
//声明变量并初始化
var f, err = os.Open(name)
```

#### 短变量声明

##### 单个变量的声明形式

```
name := 表达式
```

例如：

```go
a := 4.5
b := a * 2
```

短变量的声明主要用在局部变量的声明和初始化中，通常比较短小灵活。

如果变量会在初始化表达式后类型发生变化，或者之后才对变量赋值，这种情况下通常使用var声明变量。

##### 多个变量的声明形式

与var声明一样，多个变量也可以使用短变量声明的方式和初始化：

```go
i , j := 0, 1
f, err := os.Open(name)
```

通常，只有对可读性有帮助的时候，才会使用多个初始化表达式来进行多个变量的同时声明，例如短小且天然一组的for循环的初始化。

##### 短变量声明特殊情况

短变量在声明时，并不是所有在左边的变量都需要声明，如果左边的某些变量已经在同一个语法块中声明过了，那么对于这些变量，短声明的行为等同于赋值。

```go
in, err := os.Open(infile)
out, err := os.Create(outfile) //这里仅声明了out，但向已有的err变量赋了值
```

注意：短变量声明最少要声明一个新变量，否则将会编译错误。并且只有在**同一个**语法块中已经存在变量的情况下，短变量声明的行为才和赋值操作一样，外层的声明将被忽略。

#### 变量声明的重点

变量在声明时，需要指定变量名和初始类型（类型和初始值可以二选一），其中`:=`的作用和var相同，都是表示声明，虽然var声明时也可以指定“=” ，但是这里的“=”表示的是初始化值的意思。只有在没有var或者`:=`出现时，使用“=”才表示真正的赋值，指的是将右边的值赋给左边的对应变量。

```go
i , j =j , i //交换i和j的值
```

### 指针

指针的值是一个变量的地址（可以直接将指针理解为变量的地址），因此，一个指针指示了变量的值所保存的位置。不是所有的值都有地址，但是所有的变量都有。使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值。

例如，声明了一个变量x：

```go
var x int
```

获取变量x的地址，可以使用表达式：&x，&x表示的是获取一个指向整型变量x的指针。因此&x就代表着指针本身，它的值是一个变量的地址。在这里，它的类型是整型指针（*int）。

如果将一个指针直接赋值给了一个变量p，例如：

```go
p := &x
```

它表示的意思是：p包含变量x的地址，或者p指向变量x（指针类型的零值是nil，测试p!=nil，结果为true，说明p指向一个变量（p的值是一个变量的地址））。

在Go语言中，p指向的变量可以用`*p`来表示，也就是说这里的变量x可以直接通过`*p`来指代，换句话说，`*p`就代表着变量x，既然是变量，因此它也可以出现在赋值操作符左边，用于更新变量的值。

```go
x := 1
p := &x         //p是整型指针，指向x
fmt.Println(*p) // 输出：1
*p = 2          //*p指代的就是变量x，因此相当于是：x=2
fmt.Println(x)  //输出：2
```

综上所述：

`&x`：代表着指针本身，它的值是一个变量的地址。假如存在`p := &x`，那么p的值就是变量x的地址，此时，

`*p`：代表着p指向的变量，即x变量本身，`*p`是变量x的别名，因此`*p`也被称为变量x的指针别名。

指针是可以比较的，两个指针**当且仅当**指向同一个变量或者两者都是nil的情况下才相等。

```go
var w, y int
fmt.Println(&w == &w, &w == &y, &y == nil) //输出：true false false
```

在Go语言中，函数返回局部变量的地址（指针）是非常安全的，例如：

```go
func wy() *int {
	v := 1
	return &v //返回一个指针
}
var p1 = wy()   //p1是一个指针
fmt.Println(p1) //输出：0xc00005c080
var p2 = wy()   //p2是一个指针
fmt.Println(p2) //输出：0xc00005c088
fmt.Println(p1 == p2) //输出：false
```

上述代码中，通过调用wy()产生的局部变量v即使在函数调用返回后依然存在，指针p1依然引用它，并且每次调用wy()都会返回一个不同的指针值。

可以将指针作为参数传递给函数，在函数的内部通过`*p`来获取指向的变量，从而能够实现让函数更新间接传递的变量值。

```go
//参数是一个整型指针
func incr(p *int) int {
	//获取指针指向的变量，并加1
	*p++
	return *p //返回指向的变量的值
}
m := 1
incr(&m)              //传入m指针，m加1
fmt.Println(m)        //输出：2
fmt.Println(incr(&m)) //再次传入m指针，m再次加1，并返回m的值，所以输出：3
fmt.Println(m)        //输出：3
```

上述代码中，`*p`是变量m的指针别名，指针别名允许我们不用变量的名字来访问变量。

下面是一个flag包使用指针相关的示例，自定义了两个标识参数，-n会忽略正常输出时结尾的换行符；-s使用sep替换默认参数输出时使用的空格分隔符。

```go
//echo4 输出其命令行参数
package main

import (
	"flag"
	"fmt"
	"strings"
)
//变量sep和n是指向标识变量的指针，因此必须通过*sep和*n来访问
var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")

func main() {
	flag.Parse() //更新标识变量的默认值
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println("结束")
	}
}
```

执行结果：

```powershell
PS E:\go_cxsjyy\src\chapter2\echo4> go build
PS E:\go_cxsjyy\src\chapter2\echo4> .\echo4.exe a bc def
a bc def结束
PS E:\go_cxsjyy\src\chapter2\echo4> .\echo4.exe -s / a bc def
a/bc/def结束
PS E:\go_cxsjyy\src\chapter2\echo4> .\echo4.exe -n a bc def
a bc def
PS E:\go_cxsjyy\src\chapter2\echo4> .\echo4.exe -help
Usage of E:\go_cxsjyy\src\chapter2\echo4\echo4.exe:
  -n    omit trailing newline
  -s string
        separator (default " ")
PS E:\go_cxsjyy\src\chapter2\echo4>
```

总结：指针的作用就是实现其他语言（C#）中变量按照引用类型传递的方式。

### new函数

new函数用于创建指针。

```go
p := new(T)
```

表达式`new(T)`用于创建一个未命名的T类型的变量，并初始化为T类型的零值，并且返回其地址（指针），地址类型为`*T`。例如，当T为int时，`new(int)`返回的就是`*int`，表示的是整型指针。

```go
p := new(int)	//定义类型是整型指针（*int）的p，指针p指向未命名的int变量
fmt.Println(p)  //输出：0xc00005c080
fmt.Println(*p) //输出：0
*p = 2          //把未命名的int设置为2
fmt.Println(*p) //输出2
a := new(int)	//每一次调用new都返回一个具有唯一地址的不同变量
b := new(int)
fmt.Println(a) 	//输出：0xc00005c0b0
fmt.Println(b) 	//输出：0xc00005c0b8
```

使用new函数创建未知变量的指针时，由于不需要引入（和声明）一个虚拟的名字，因此可以直接在表达式中使用。

下面的两个`newInt`函数行为相同，相互等价：

```go
func newInt() *int {
	return new(int)
}
func newInt2() *int {
	var dumy int
	return &dumy
}
```

备注：new是一个预声明的函数，不是一个关键字。

### 变量的生命周期

生命周期指的是：在程序执行过程中，变量存在的时间段。

包级别的变量：它的生命周期是整个程序的执行时间。

局部变量的生命周期：

- 每次执行声明语句时创建一个新的实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收。
- 函数的参数和返回值也是局部变量，它们在其闭包函数被调用的时候创建。

#### 变量逃逸

```go
var global *int
func f() {
	var x int
	x = 1
	global = &x
}
```

虽然x是一个局部变量，但是它在f函数返回以后还可以通过global变量访问，这种情况称为x从f中逃逸。因此，在上述代码中，x一定使用的是堆空间。

注意：每一次变量逃逸都需要一次额外的内存分配过程。如果在长生命周期对象中，保持着短生命周期对象不必要的指针，就会发生变量逃逸。特别是在全局变量中，这种变量逃逸会阻止垃圾回收器回收短生命周期的对象空间。



## 赋值

赋值语句用来更新变量所指的值。

```go
x = 1                       //有名称的变量赋值
*p = true                   //间接变量赋值
person.name = "bob"         //结构体成员赋值
count[x] = count[x] * scale //数组元素的赋值
y *= 2                      //等同于：y=y*2
v++
v--
```

### 多重赋值

多重赋值：多个变量一次性被赋值。

```go
i, j, k = 2, 3, 5
```

多重赋值在实际更新变量前，右边所有的表达式会先被推演。

示例一，交换两个变量的值：

```go
x，y = y, x
a[i], a[j] = a[j], a[i]
```

示例二，计算两个整数的最大公约数：

```go
func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}
```

示例三，计算斐波那契数列的第n个数：

```go
func fib(n int) int {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		x, y = y, x+y
	}
	return x
}
```

### 可赋值性

不管隐式还是显式赋值，如果左边的变量和右边的值类型相同，它就是合法的。

nil可以被赋给任何接口变量或引用类型。

如果两个值能够使用==和!=进行比较，必须满足的条件：其中一个操作数相对于另一个操作数的类型必须是可赋值的。



## 类型声明

