# Go 基本数据类型

[TOC]

## 类型声明

type声明定义了一个新的命名类型，它和某个已有类型使用同样的底层类型。

命名类型的主要作用就是与底层类型的使用相互隔离，避免相互混乱使用。

即使两个命名类型使用了相同的底层类型，它们也不是相同的类型，仍然是不同的类型，所以它们不能使用算术表达式进行比较和合并。

命名类型的声明：

```
type name underlying-type
```

类型的声明通常出现在包级别，这里命名的类型在整个包中可见，如果名字是导出的（开头使用大写字母），其他的包也可以访问它。

命名类型的底层类型决定了它的结构和表达方式，以及它支持的内部操作集合，这些内部操作与直接使用底层类型的情况相同。

```go
package main

//定义两个类型
type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	boilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
	return Fahrenheit(c*9/5 + 32)
}
func FToC(f Fahrenheit) Celsius {
	return Celsius((f - 32) * 5 / 9)
}
func main() {
	//fmt.Println(Celsius(2.0) == Fahrenheit(2.0)) //编译错误
	fmt.Println(Celsius(2.0) == Celsius(Fahrenheit(2.0))) //输出true
    fmt.Println(float64(Celsius(2.0)) == float64(Fahrenheit(2.0))) //输出true
}
```

在上述代码中，即使Celsius和Fahrenheit都使用了相同的底层类型float64，它们也不是相同的类型，所以不能使用算术表达式进行比较和合并。要想解决这个问题，必须显式的进行类型转换。

对于每个类型T，都有一个对应的类型转换操作T(x)将值x转换为类型T。

如果两个类型具有相同的底层类型，或二者都是指向相同底层类型变量的未命名指针类型，则二者是可以相互转换的。

类型转换不改变类型值的表达方式，仅改变类型。

命令类型一般通常用于底层类型是复杂结构体类型，可以避免一遍遍地重复写复杂的类型。



## 查看数据类型

可以通过将任何值传递给reflect包的TypeOf函数，来查看它们的类型。

```go
package main
import (
	"fmt"
	"reflect"
)

func main(){
	fmt.Println(reflect.TypeOf(42))
	fmt.Println(reflect.TypeOf(true))
	fmt.Println(reflect.TypeOf("hello ,Go!"))
}
```



## 数值类型（number）

Go的数值类型包括：

- 整数
- 浮点数
- 复数

不同的数值类型分别有自己的大小。

### 整数

在Go语言中，整数类型分为：有符号整数和无符号整数。

| 位数大小 | 有符号整数 | 无符号整数 |
| -------- | ---------- | ---------- |
| 8位      | int8       | uint8      |
| 16位     | int16      | uint16     |
| 32位     | int32      | uint32     |
| 64位     | int64      | uint64     |

除此之外，还有两种类型：int和uint。在特定平台上，其大小与原生的有符号整数/无符号整数相同，或等于该平台上的运算效率最高的值。int是目前使用最广泛的数值类型。int和uint的类型大小和平台相关（32位或者64位）。

rune类型是int32类型的同义词，通常用于指明一个值是Unicode码点（code point）。这两个名称可以互换。

byte类型是uint8类型的同义词，通常用于强调一个值是原始数据，而非量值。

uintptr：一种特殊的无符号整数，大小并不明确，但足以完整存放指针。uintptr类型仅仅用于底层编程。

int、uint 和 uintptr 都有别于其大小明确的相似类型的类型。（例如：int和int32是不同类型，尽管int天然的大小就是32位，并且int值若要当作int32使用，必须显式转换。）

有符号整数的n位数字的取值范围是： -2^n-1^ ~ 2^(n-1）^-1，由于需要保留最高位作为符号位来表示正数或者复数，因此在次方上减1。例如，int8的取值范围为：-128 ~ 127。

无符号整数的n位数字的取值范围是： 0 ~ 2^n^-1，无符号整数都是非负数。例如，uint8的取值范围为：0 ~ 255。

#### 二元运算符

Go的二元操作符包括算术、逻辑、比较、位运算等，按优先级的降序排列如下：

1.   `*` 	`/`	`%`	`<<`	`>>`	`&`	`&^`
2.   `+`	 `-`    `|`    `^`
3.   `==`   `!=`  `<`    `<=`    `>`    `>=`
4.   `&&`
5.   `||`

二元运算符分五大优先级，同级别的运算符满足左结合律，可以通过圆括号按指定次序计算。

在Go语言中，取模运算符 % 仅能用于整数，用于取余计算。并且，**取模余数的正负号总是与被除数一致**，例如：-5%3 和 -5%-3 计算结果都是 -2。整数的除法运算（/）结果仍然是整数（会舍弃小数部分），例如 5/4结果为1。

在Go语言中，整数类型发生了溢出时（算术运算结果所需的位超出该类型的范围），溢出的高位部分会无提示地丢弃，并不会报异常。假如原本的计算结果是有符号类型，且最左侧位是1，则会形成负值，例如：

```go
var i int8 = 127
fmt.Println(i + 1) //结果为：-128
fmt.Println(i * i) //结果为：1

var u uint8 = 255
fmt.Println(u + 1) //结果为：0
fmt.Println(u * u) //结果为：1

var u2 uint8 = 0
fmt.Println(u2 - 1) //结果为：255
```

#### 位运算符

```go
&      位运算 AND
|      位运算 OR
^      位运算 XOR
&^     位清空（AND NOT）
<<     左移
>>     右移
```

可以通过如下方式查看各种数字的二进制表示形式：

```go
//输出16对应的10进制和二进制表示形式
fmt.Printf("%d：%b \n", 16, 16) //16：10000
//输出指定位数的10进制和二进制表示形式，%08b表示显示8个位数，不足的前面补0
fmt.Printf("%3d：%08b \n", 16, 16) // 16：00010000（16的前面有一个空格）
```

Go允许你在程序代码中使用八进制表示法来编写数字。任何以0开头的数字序列都将被视为八进制数。

```go
//输出16对应的10进制和八进制表示形式
fmt.Printf("%3d：%04o \n", 16, 16) // 16：0020
```

运算符`&`：表示按位与，只有当其左边值中的对应位和右边值中的对应位都为1时，它才会将位设置为1。（只要有一个不为1，结果就是0）

运算符`|`：表示按位或，如果左边值中的对应位的值，或右边值中的对应位的值，只有有一个为1，结果中的位的值就为1。（只有两个都为0的情况下，结果才为0）

运算符`^`：作为二元运算符，它表示按位“异或”（XOR）；作为一元前缀运算符，它表示按位取反或按位取补，运算结果就是操作数逐位取反。

运算符`&^`：表示按位清除（AND NOT），表达式 `z=x&^y` 中，若y的某位是1，则z的对应位等于0；否则，它就等于x的对应位。

算术上，左移运算 x << n 等价于 x乘以 2^n；而右移运算 x >> n 等价于 x 除以 2^n，向下取整。因此 x >> 1等同于 x/2，可直接用于奇偶数判断。

左移以0填补右边空位，无符号整数右移同样以0填补左边空位，但有符号数的右移操作是按符号位的值填补空位。因此，**如果将整数以位模式处理，必须使用无符号整型**。

#### 无符号整数注意事项

- 整数类型（包括无符号整数）在算术溢出的时候，可能会得到意想不到的值，因此无符号整数往往**只用于**位运算符和特定算术运算符。
- 即使要表示非负数，也最好不要使用无符号整数，原因是无符号整数一旦牵扯到算术运算，往往会得到意想不到的结果。例如无符号整数值为0，减一之后，将变成对应位的最大值，如上述示例中的u2。
- 无符号整数最好只用于位运算符，除此之前，尽量不要使用。

#### 其他类型转换为整型

浮点型转成整型，会舍弃小数部分，趋零截尾（正值向下取整，负值向上取整）。

#### 整数的不同进制表示方式

不论有无大小和符号限制，源码中的整数都能写成常见的十进制数；

也能写成八进制数，以0开头，如0666；

还能写成十六进制数，以0x 或 0X开头，如0xdeadbeef。（十六进制的数字或字母大小写皆可）。

示例：

```go
o := 0666                           //定义一个八进制数
fmt.Printf("%d \n", o)              //输出：438
fmt.Printf("%o \n", o)              //输出：666
fmt.Printf("%#o \n", o)             //按照标准前缀，输出：0666
fmt.Printf("%d %[1]o %#[1]o \n", o) //输出：438 666 0666

fmt.Printf("%x \n", o)  //输出：1b6
fmt.Printf("%X \n", o)  //输出：1B6
fmt.Printf("%#x \n", o) //输出：0x1b6

x := int64(0xdeadbeef)                   //定义十六进制数
fmt.Printf("%d %[1]x %#[1]x %#[1]X ", x) // 输出：3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```

使用fmt包输出数字时，可以使用谓词%d、%o、%x指定进位制基数和输出格式，%d表示10进制，%o表示八进制，%x表示十六进制。

谓词%后的[1]告知Printf重复使用第一个操作数；%后的#告知Printf输出相应的前缀0（八进制）、0x或0X（十六进制）。除了十进制外，为了能够标准的输出对应进制位的值，建议始终使用#。

### 浮点数

Go具有两种大小的浮点数：float32和float64。

常量math.MaxFloat32是float32的最大值；常量math.MaxFloat64是float64的最大值。

```go
var f1 float32 = 999999
fmt.Println(f1) //输出：999999

var f2 float32 = 999999 + 1
fmt.Println(f2) //输出：1e+06

var f3 float32 = 16777216 //临界值
fmt.Println(f3 == f3+1)   //输出：true
```

十进制下，float32的有效数字大约是6位，float64的有效数字大约是15位。（如上述代码中的f1和f2）。

注意：float32能精确表示的正整数范围有限（大约<=16777216），因此应优先使用float64。

浮点数更多的使用用于表示小数。

小数点前的数字可以省略（.707），后面的也可以省去（1.）。非常小或非常大的数字最好使用科学计数法表示。

用于输出浮点值的Printf谓词有：

- %g：该谓词会自动保持足够的精度，并选择最简洁的表示方式。
- %e：按照有指数的形式表示数据表。
- %f：按照无指数的形式表示数据表。

下述代码按8个字符的宽度输出自然对数e的各个幂方，结果保留三位小数：

```go
for x := 0; x < 8; x++ {
	//fmt.Println(math.Exp(float64(x))) //输出自然对数e的各个幂方值
	fmt.Printf("x=%d e^x=%8.3f \n", x, math.Exp(float64(x)))
}
```

输出结果：

```
x=0 e^x=   1.000 
x=1 e^x=   2.718 
x=2 e^x=   7.389 
x=3 e^x=  20.086 
x=4 e^x=  54.598 
x=5 e^x= 148.413 
x=6 e^x= 403.429 
x=7 e^x=1096.633 
```

#### math包中的特殊值

正无穷大（+Inf）和负无穷大（-Inf）：表示超出最大许可值的数及除以零的商。

NaN（Not a Number）：表示数学上无意义的运算结果（如0/0，或Sqrt(-1)）。

math.IsNaN 函数判断其参数是否是非数值。

math.NaN 函数则返回非数值（NaN）。

在数字运算中，我们倾向于将NaN当作信号值，但直接判断具体的计算结果是否为NaN可能导致潜在错误，因为与NaN的比较总不成立。

### 复数

Go具备两种大小的复数：complex64和complex128，二者分别由float32和float64构成。

通过内置的complex函数，根据给定的实部和虚部创建复数。

提取复数的实部时，使用内置的real函数；提取复数的虚部时，使用内置的imag函数。

如果在浮点数或十进制数后面紧接着写字母i，如3.12i或2i，它就变成了一个虚数。



## 布尔值

在Go语言中，&&的优先级比||高。



## 字符串

在Go语言中，内置的 len 函数返回的是字符串的**字节数**，而不是文字符号的数目。而下标访问操作 s[i] 则取得第i个字符，其中 0<=i<len(s)。

注意：字符串的第 i 个字节不一定就是第 i 个字符，因为非 ASCII 字符的 UTF-8 码点需要两个字节或多个字节。

### 字符串操作

`s[i:j]`：按照原字符串的**字节**的下标方式来产生新字符串，下标从`i`（含边界值）开始，直到`j`（不含边界值），结果的大小为`j-i`个字节。在使用时，如果省略了i或者j，则取其默认值，操作数i的默认值为字符串的起始位置，值为0；操作数j的默认值为字符串的终止位置，值为len(s)。

### 字符串字面量

字符串字面量指的是形式上带双引号的字节序列，简单点理解就是一个带双引号的字符串。

Go的源文件总是按UTF-8编码，Go的字符串也会按UTF-8解读，因此在源码中，可以直接将Unicode码点写入到字符串字面量中。

字符串字面量中的常用转义符：

```
\a      响铃
\b      退格
\f      换页
\n      换行
\r      回车
\t      制表符
\v      垂直制表符
\'      单引号（只用在 '\'' 形式的rune符号面值中）
\"      双引号（只用在 "..." 形式的字符串面值中）
\\      反斜杠
```

原生的字符串字面量的书写形式是\`...\`，使用反引号而不是双引号。

在原生的字符串字面量中，转义符不起作用。并且人为的回车后，在处理时会删除回车符（换行符会保留），因此可以将字符串字面量展开多行显示。

### Unicode

Unicode囊括了世界上所有文书体系的全部字符。每一个字符都对应一个叫Unicode码点的标准数字。在Go的术语中，这些字符记号称为文字符号（rune）。





### UTF-8

### 字符串和字节 slice

### 字符串和数字的相互转换

todo: Head Frist Go语言程序设计，附录B中的“更多关于符文的信息部分”

## byte类型





## 类型之间的相互转换

### `[]byte` <=> string

[]byte 转换成string：

```go
string([]byte{72,101})
```

string转换为[]byte：

```go
[]byte("hello")
```



