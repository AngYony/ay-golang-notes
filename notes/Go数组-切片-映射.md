# Go数组-切片-映射



## 数组

数组保存特定数量的元素，不能增长或收缩。

在Go语言中，数组中的元素索引从0开始。

创建数组时，它所包含的所有值都初始化为数组所保存类型的零值（默认值）。

### 声明数组

#### 方式一

语法：

```
var 数组变量名 [个数]类型
```

示例：

```go
var myArray [4]string	//创建一个由4个字符串组成的数组
var myIntArray [5] int  //创建一个由5个整数组成的数组
var dates [3]time.Time  //创建一个由3个Time值组成的数组
```

#### 方式二：数组字面量

如果事先知道数组要存储的值，可以使用数组字面量的形式初始化数组。

示例：

```go
var notes [3]string = [3]string{"AA", "BB", "CC"}
fmt.Println(notes[0])
myArray := [3]int{1, 2, 3}	//短变量声明形式
fmt.Print(myArray[2])
```



### 获取或设置数组中的元素的值

直接通过索引下标进行设置和读取。

示例：

```go
myArray[0]="one"		//设置元素的值
myArray[1]="two"		
fmt.Println(myArray[2]) //读取元素的值
```

### 数组相关的其他操作

#### 获取数组的长度

使用len()函数返回数组的长度（它包含的元素个数）。

```go
var myArr [3]int = [3]int{1, 2}
fmt.Println(len(myArr))		//输出：3
```

声明数组时，长度设置的是几，len()函数就返回几，而不用管其中的元素是否赋值（没有显式设置值的元素将使用默认值）

#### 使用for...range循环遍历数组

处理数组中每个元素的一种更安全的方法是使用特殊的for...range循环。

格式：

```go
for index,value := range myArray{
	//循环体
}
```

格式说明：

- index：保存每个元素索引的变量
- value：保存每个元素值的变量
- myArray：正在处理的数组

示例：

```go
for index, value := range notes {
	fmt.Println(index, value)
}
```

输出：

```
0 AA
1 BB
2 CC
```

如果在遍历的过程中，不想使用其中声明的变量index或value，那么可以使用空白标识符（_）来代替变量名。这将导致Go丢弃该值，而不会产生编译器错误。



### 使用“fmt”输出数组元素

```go
var notes [3]string = [3]string{"AA", "BB", "CC"}
fmt.Println(notes)       //输出：[AA BB CC]
fmt.Printf("%#v", notes) //输出：[3]string{"AA", "BB", "CC"}
```

### 数组中元素的默认值

- int类型的元素默认值为0
- string类型的元素默认值为空字符串。



## 切片

每一个切片都构建于一个底层的数组之上。实际上是底层的数组存储了切片的数据；切片仅仅是数组中的一部分（或者所有）元素的视图。

切片是一个可以通过增长来保存额外数据的集合类型，它是Go的一个数据结构。

与数组相同的是，切片由多个相同类型的元素构成。不同的是，切片允许我们在结尾追加更多的元素。

### 声明切片

除了不指定大小，与声明一个数组变量的语法完全相同。

#### 方式一：使用声明变量的形式或make()创建切片

```
var 切片变量 []类型
```

不像数组变量，声明切片变量并不会自动创建一个切片。可以调用内建的make函数。传递给make你想要创建的切片的类型（这个类型与你想要赋值的变量的类型相同）和需要创建的切片的长度。

> 当你使用make函数或者切片字面量创建一个切片的时候，底层的数组会自动创建出来（只有通过切片，你才能访问它）。

```go
var notes []string        //声明一个切片变量
notes = make([]string, 7) //创建存储7个字符串的切片
notes[0] = "你好"
fmt.Printf("%#v\n", notes)
```

输出：

```
[]string{"你好", "", "", "", "", "", ""}
```

或者使用短变量声明（推荐）：

```go
nums := make([]int, 3)
```

#### 方式二：切面字面量

切片字面量的方括号中是空的，并且不需要调用make函数；在代码中使用一个切片字面量会创造一个预填充的切片。

```go
wy := []string{"one", "two"}
```

#### 方式三：切片运算符（不推荐，需要关注底层数组对切片的影响）

创建一个数组，然后再基于数组通过切片运算符创建一个切片。

```go
myArray := [5]int{1, 2, 3, 4, 5}	//创建一个数组
mySlice := myArray[1:3]				//基于数组创建切片
fmt.Println(mySlice)				
```

输出：

```
[2 3]
```

切片运算符有两个索引：其中一个标识切片开始的位置，另一个标识切片在此位置之前结束。

> 如果你使用`underlyingArray[i：j]`作为切片的运算符，生成的切片实际上包含元素`underlyingArray[i]`到元素`underlyingArray[j-1]`。

切片运算符默认需要两个索引。

如果忽略了开始的索引，默认从0开始；如果忽略了结束索引，默认取剩余的全部元素。

```go
myArray := [5]int{1, 2, 3, 4, 5}
mySlice = myArray[:4]
fmt.Println(mySlice)	//输出：[1 2 3 4]
mySlice = myArray[3:]
fmt.Println(mySlice)	//输出：[4 5]
```

### 切片其他操作

#### 获取切片的长度

```
len(notes)
```

#### 添加元素

Go提供一个内建的函数append来将一个或者多个值追加到切片的末尾，并返回追加后的切片。

```go
mySlice := []int{1, 2, 3, 4, 5}
mySlice = append(mySlice, 6)    //追加一个元素
mySlice = append(mySlice, 7, 8) //同时追加两个元素
fmt.Println(mySlice)            //输出：[1 2 3 4 5 6 7 8]
```

> 切片的底层数组并不能增长大小。如果数组没有足够的空间来保存新的元素，所有的元素会被拷贝至一个新的更大的数组，并且切片会被更新为引用这个新的数组。但是由于这些场景都发生在append函数内部，无法知道返回的切片与传入append函数的切片是否具有相同的底层数组。如果你保留了两个切片，会导致一些非预期的错误。

注意：切片是底层数组的视图，当使用append()添加元素时，会出现不同切片具有相同或不同的底层数组的情况。例如：

```go
s1 := []int{1, 2, 3}
s2 := append(s1, 4, 5)
s2[0] = 0           //更改了s2的第一个元素，s1没发生变化
fmt.Println(s1, s2) //此处输出：[1 2 3] [0 2 3 4 5]，s1的值并没有被改变
s3 := append(s2, 6, 7)
s4 := append(s3, 8, 9, 10)
fmt.Println(s3, s4) //此处输出：[0 2 3 4 5 6 7] [0 2 3 4 5 6 7 8 9 10]
s4[0] = 111         //更改s4的第一个元素，发现对应的s3的第一个元素也发生了改变
fmt.Println(s3, s4) //输出：[111 2 3 4 5 6 7] [111 2 3 4 5 6 7 8 9 10]
```

上述代码中，特定情况下，可能共享同一个底层数组，此时对一个切片的更改，会影响共享该底层数组的其他切片的值。

因此调用append函数，惯例是将函数的返回值赋给你传入的那个切片变量。如果你只保存一个切片，你就无须考虑两个切片是否共享了同一个底层数组。

如果为append函数传入nil切片，它会当做一个空的切片来处理，append函数会在幕后创建一个切片，并返回添加了元素之后的切片。

因此，不用担心为append函数传入的切片变量是否是nil还是空，都可以正常被处理。



### 切片和数组之间的关系

切片并不会自己保存任何数据，它仅仅是底层数组的元素的视图。

甚至可以有多个切片都指向相同的底层数组。每一个切片会是一个指向数组元素的子集的视图。

==注意：由于切片只是底层数组内容的视图，如果你修改底层数组，这些变化也会反映到切片。给切片的一个元素赋一个新值也会修改底层数组相应的元素。==

```go
myArray := [5]int{1, 2, 3, 4, 5}
mySlice := myArray[:3]
fmt.Println(mySlice) 	//输出：[1 2 3]
myArray[0] = 11	     	//修改底层数组的一个元素值
fmt.Println(mySlice) 	//输出：[11 2 3]
mySlice[1] = 22			//修改切片中的元素的值
fmt.Println(myArray) 	//输出：[11 22 3 4 5]
```

**修改底层数组的一个元素值，对应的切片的元素值也会一起被修改。同样，修改切片中的元素的值，也会修改底层数组相应的元素的值。**

==如果多个切片指向了同一个底层数组，数组的元素修改会反映给所有的切片。==

### 切片中元素的默认值

与数组一样，如果你访问了一个切片中没有赋值的元素，你会得到那个元素类型的零值（默认值）。

和数组不同的是，切片变量自己也有0值：nil。一个没有赋值的切片变量值为nil。如果输入参数是一个nil切片那么len返回0。

```go
fmt.Println(len(intSlice)) //把nil切片传递给len函数，它会返回0，就像传入了一个空的切片一样
```



## 映射

映射相当于C#中的键值对。可以使用任意类型来作为映射的键，前提是该类型允许进行`==`比较操作。

### 声明映射

在Go语言中，使用map关键字来创建映射，后面跟着一对包含键类型的方括号（`[]`）。

#### 方式一：使用声明变量的形式或make函数创建映射

```go
var myMap map[string]float64
```

仅仅声明一个映射变量，并不会自动创建一个映射，需要调用make函数。

```go
myMap = make(map[string]float64)
```

或者，直接使用短变量名的形式创建映射：

```go
ranks := make(map[string]int)
```

映射的元素赋值和C#中的键值对赋值基本一样，通过键访问来获取或设置对应的值。

注意：映射不需要显式的添加键，直接可以通过下述代码进行键和值的设置。

```go
myMap["aa"] = 1.1
myMap["bb"] = 2.2
```

#### 方式二：映射字面量

对于每一个键/值对，包含一个键、一个冒号和值。多个键/值对之间以逗号分隔。

映射字面量示例如下：

```go
myMap := map[string]float64{"aa": 1.1, "bb": 2.2}
```

如果要创建一个空的映射，只需要花括号的内容为空即可。

```go
myMap2 := map[string]float64{}
```

### 映射的其他操作

#### 删除键值对

使用内置函数delete来删除映射中的键和值。第一个参数为映射变量，第二个参数为键。

```go
delete(myTestMap, "A")
```

#### 遍历映射

使用for...range循环来遍历映射。

==注意：在不进行特殊处理的情况下，映射的键和值是按照随机顺序展示的。如果需要有序输出，需要借助额外的数组或切片，按照键排序后，再输出==

同时获取键和值：

```go
for key, val := range myTestMap {
	fmt.Println(key, val)
}
```

仅获取键：

```go
for key := range myTestMap {
	fmt.Println(key)
}
```

仅获取值，需要将键赋给“_”空白标识符：

```go
for _, val := range myTestMap {
	fmt.Println(val)
}
```



### 映射中的零值（默认值）

映射类型的变量本身的零值是nil。如果声明了一个映射变量但是未赋值，它的值是nil。此时如果尝试增加键或值，将会产生一个错误。因此在增加一个新的键/值对之前，需要使用make或者映射字面量来创建一个映射，并且赋值给映射变量。

映射中值的零值由映射中的值的类型决定。零值可以让你更加安全地修改映射的值，即使在没有赋值给它的情况下。

```go
cnts := make(map[string]int)
cnts["aa"]++
cnts["aa"]++
cnts["bb"]++
fmt.Println(cnts)	//输出：map[aa:2 bb:1]
```

### 如何区分已经赋值的值和零值

在访问映射键的时候，会返回可选的第2个布尔类型的值，如果这个键已经被赋值过，那么返回true，否则返回false。

如下所示：

```go
myTestMap := map[string]int{}
myTestMap["A"] = 1
value, ok := myTestMap["A"]
fmt.Println(value, ok) //输出：1 true
myTestMap["B"] = 0     //直接复制为int类型的零值0
value, ok = myTestMap["B"]
fmt.Println(value, ok)     //输出：0 true
value, ok = myTestMap["C"] //直接访问未被赋过值的键
fmt.Println(value, ok)     //输出：0 false
//如果仅仅是为了判断值是否存在，可以直接使用“_”空白标识符来忽略value
_, ok = myTestMap["C"]
fmt.Println(ok) //输出：false
if !ok {
    fmt.Println("不存在键为C的值")
}
```

