# Go 面试题积累



## Golang相关

### Go语言中的垃圾回收

垃圾回收：对程序中不再使用的内存资源进行自动回收的操作。

#### 垃圾回收算法：

- **引用计数**：对象被创建或被引用时计数+1，对象引用失效或者被销毁计算-1，当计数=0时，回收该对象。缺点是不能很好的处理循环引用。

- **标记-清除**：从根变量遍历所有引用的对象，有被引用标记为被引用，最后将没有被标记的进行回收。确定是需要STW，暂时停止程序运行。
  - **三色标记法**：白色到灰色，再到黑色的过程。
    - 初始状态下所有对象都是白色。
    - 从根节点遍历所有对象，将遍历的对象变为灰色对象
    - 将灰色对象下的所有引用的对象也变成灰色，然后将遍历过的灰色对象变为黑色对象。
    - 重复上述步骤，直到灰色对象全部变黑色。
    - 通过写屏障检测对象是否有变化，重复上述操作。
    - 最后所有的白色标记的对象就是要回收的垃圾。
  - STW：为了避免在GC的过程中，对象的引用关系发生变化，使得GC的结果发生错误，而暂时停止所有正在运行的协程的操作叫 STW。
  - 写屏障：通过写屏障技术尽可能地缩短STW的时间（程序暂停的时间）。
- **分代收集**：按照对象生命周期的长短，分成不同代空间，不同代空间有不同的回收算法和频率。



### MPG 模型

M：代表真正的内核OS线程（物理线程）

P：调度器，代goroutine调度的上下文，可以把它看作一个局部的调度器，使go代码在某一个线程上跑，它是实现从 N：1到 N：N 映射的关键。

G：协程（goroutine），它有自己的栈，instruction pointer和其它信息（正在等待的channel等等），用于调度。

三者关系：P管理着一组G挂载在M上运行。M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。

#### Goroutine 调度策略

- 队列轮转：P周期性的将G调用到M中执行，执行一段时间后，保存上下文，并将G放到队列的尾部，然后从队列中再取一个G进行调度。同时，P还会周期性的查看全局队列是否有G等待调度到M中执行。
- 系统调用：当G0进入到系统调用时，M0将会释放P，进而某个空闲的M1获取P，执行P队列中剩下的G。
  - 如果G0协程阻塞，这是就会创建M1主线程或从线程池中取出M1，并且将等待的G挂到M1下开始执行，M0仍然可以继续做自己的事情。
  - 当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。



#### CSP 模型

用于描述两个独立的并发实体通过共享的通讯 channel (管道)进行通信的并发模型。





### channel 相关

- 向已关闭的Channel发送数据，引发panic，接收数据，返回缓冲值或零值。
- nil通道，无论收发都会阻塞。
- 重复关闭，或者关闭nil通道都会引发panic。

总结：channel关闭：收“值”发“异”；channel nil：收发全阻。其他关闭，全部异常。

channel中包括一个环形的缓冲区，通过recvx和sendx指向读取和插入的位置。同时还包括两个用来发送和接收的协程队列。



### Mutex 状态







### context 结构和原理

Context（上下文）是Golang应用开发常用的并发控制技术 ，它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。Context 是并发安全的，主要是用于控制多个协程之间的协作、取消操作。

结构：

```
type Context interface {
   Deadline() (deadline time.Time, ok bool)
   Done() <-chan struct{}
   Err() error
   Value(key interface{}) interface{}
}
```

- 「Deadline」 方法：可以获取设置的截止时间，返回值 deadline 是截止时间，到了这个时间，Context 会自动发起取消请求，返回值 ok 表示是否设置了截止时间。
- 「Done」 方法：返回一个只读的 channel ，类型为 struct{}。如果这个 chan 可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。
- 「Err」 方法：返回Context 被取消的原因。
- 「Value」 方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。



### 竞态、内存逃逸

竞态：资源竞争，就是在程序中，同一块内存同时被多个 goroutine 访问。我们使用 go build、go run、go test 命令时，添加 -race 标识可以检查代码中是否存在资源竞争。解决方式，加锁。

逃逸场景：

- 指针逃逸
- 栈空间不足逃逸
- 动态类型逃逸
- 闭包引用对象逃逸



### GC的触发条件

主动触发(手动触发)，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。
被动触发，分为两种方式：

- 使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认100%，即当内存扩大一倍时启用GC。
- 使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC。



### Go值接收者和指针接收者的区别？

**究竟在什么情况下才使用指针？**

**参数传递中，值、引用及指针之间的区别！**

方法的接收者:

- 值类型，既可以调用值接收者的方法，也可以调用指针接收者的方法；
- 指针类型，既可以调用指针接收者的方法，也可以调用值接收者的方法。

但是接口的实现，值类型接收者和指针类型接收者不一样：

- 以值类型接收者实现接口，类型本身和该类型的指针类型，都实现了该接口；
- 以指针类型接收者实现接口，只有对应的指针类型才被认为实现了接口。

通常我们使用指针作为方法的接收者的理由：

- 使用指针方法能够修改接收者指向的值。
- 可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。



### 内存对齐

==CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。==比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。

CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数。

合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。



### 各种比较问题

#### struct 能不能比较

- 相同struct类型的可以比较
- 不同struct类型的不可以比较,编译都不过，类型不匹配

#### 接口能不能比较

Nil相等吗？

判断两个interface{}是否相等：

```go
reflect.DeepEqual(a, b interface{})
```

将一个interface{}赋值给另一个interface{}：

```go
reflect.ValueOf(a).Elem().Set(reflect.ValueOf(b))
```







### go 打印时 %v %+v %#v 的区别？

- %v 只输出所有的值；
- %+v 先输出字段名字，再输出该字段的值；
- %#v 先输出结构体名字值，再输出结构体（字段名字+字段的值）；





### 空结构体 struct{} 用途

空结构体 struct{} 实例不占据任何的内存空间。一般作为占位符使用。

例如：

1、将map的值的类型设为struct{}，就封装了一个性能强的键集合。

2、不发送数据的信道(channel)，使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。

3、



### Golang Map底层实现和如何扩容







### 测试相关

Go convey：单元测试框架，能够自动监控文件修改并启动测试，并可以将测试结果实时输出到 Web 界面。go convey 提供了丰富的断言简化测试用例的编写  





## 网络相关



## 数据库相关

























## 单词

unsafe.Pointer

unsafe.Sizeof

Mutex / RWMutex 

reflect.DeepEqual 、 elem

sync.WaitGroup













##  死锁产生的必要条件

产生死锁必须同时知足如下四个条件，只要其中任一条件不成立，死锁就不会发生。spa

- 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时如有其余进程请求该资源，则请求进程只能等待。blog
- 不剥夺条件：进程所得到的资源在未使用完毕以前，不能被其余进程强行夺走，即只能 由得到该资源的进程本身来释放（只能是主动释放)。进程
- 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其余进程占有，此时请求进程被阻塞，但对本身已得到的资源保持不放。资源
- 循环等待条件：存在一种进程资源的循环等待链，链中每个进程已得到的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有

